   Compiling mc-indexer-extractor v0.1.0 (/Users/bob/code/indexer/crates/extractor)
error: lifetime may not live long enough
  --> src/registry.rs:85:13
   |
28 | impl<'b, 'a: 'b> Registry<'a> {
   |      --  -- lifetime `'a` defined here
   |      |
   |      lifetime `'b` defined here
...
85 |             self.enqueue_execution(step, &child);
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`
   |
   = help: consider adding the following bound: `'b: 'a`

error[E0621]: explicit lifetime required in the type of `executable`
  --> src/registry.rs:85:13
   |
76 |     fn enqueue_children_execution(&mut self, step:usize, executable: &Executable, ast_node: &'b ASTNode){
   |                                                                      ----------- help: add explicit lifetime `'a` to the type of `executable`: `&'a Executable<'_>`
...
85 |             self.enqueue_execution(step, &child);
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'a` required

error[E0621]: explicit lifetime required in the type of `executable`
  --> src/registry.rs:85:13
   |
76 |     fn enqueue_children_execution(&mut self, step:usize, executable: &Executable, ast_node: &'b ASTNode){
   |                                                                      ----------- help: add explicit lifetime `'a` to the type of `executable`: `&Executable<'a>`
...
85 |             self.enqueue_execution(step, &child);
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'a` required

warning: unused variable: `id`
  --> src/registry.rs:89:14
   |
89 |         for (id, e) in executables.iter() {
   |              ^^ help: if this is intentional, prefix it with an underscore: `_id`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `ast_node`
  --> src/registry.rs:88:95
   |
88 |     pub fn bulk_enqueue_execution(self, step:usize, executables: &HashMap<usize, Executable>, ast_node: &'b ASTNode) -> Self {
   |                                                                                               ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ast_node`

error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable
  --> src/registry.rs:90:13
   |
90 |             self.enqueue_execution(step, e);
   |             ^^^^ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
88 |     pub fn bulk_enqueue_execution(mut self, step:usize, executables: &HashMap<usize, Executable>, ast_node: &'b ASTNode) -> Self {
   |                                   +++

error[E0621]: explicit lifetime required in the type of `executables`
  --> src/registry.rs:90:13
   |
88 |     pub fn bulk_enqueue_execution(self, step:usize, executables: &HashMap<usize, Executable>, ast_node: &'b ASTNode) -> Self {
   |                                                                  --------------------------- help: add explicit lifetime `'a` to the type of `executables`: `&HashMap<usize, Executable<'a>>`
89 |         for (id, e) in executables.iter() {
90 |             self.enqueue_execution(step, e);
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'a` required

warning: unused variable: `id`
  --> src/registry.rs:95:14
   |
95 |         for (id, e) in filled_queueable_iterish.iter() {
   |              ^^ help: if this is intentional, prefix it with an underscore: `_id`

error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable
  --> src/registry.rs:96:13
   |
96 |             self.enqueue_children_execution(step, e, &ast_node);
   |             ^^^^ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
94 |     pub fn bulk_enqueue_children_execution(mut self, step:usize, filled_queueable_iterish: &HashMap<usize, Executable>, ast_node: &'b ASTNode) -> Self {
   |                                            +++

error[E0621]: explicit lifetime required in the type of `belongs_to`
  --> src/executable.rs:52:9
   |
44 |           belongs_to: Option<&Executable>,
   |                       ------------------- help: add explicit lifetime `'a` to the type of `belongs_to`: `Option<&'a Executable<'_>>`
...
52 | /         Self {
53 | |             id,
54 | |             name,
55 | |             fulltype,
...  |
64 | |             iter,
65 | |         }
   | |_________^ lifetime `'a` required

error[E0621]: explicit lifetime required in the type of `belongs_to`
  --> src/executable.rs:52:9
   |
44 |           belongs_to: Option<&Executable>,
   |                       ------------------- help: add explicit lifetime `'a` to the type of `belongs_to`: `Option<&Executable<'a>>`
...
52 | /         Self {
53 | |             id,
54 | |             name,
55 | |             fulltype,
...  |
64 | |             iter,
65 | |         }
   | |_________^ lifetime `'a` required

warning: unused variable: `i`
  --> src/executable.rs:77:44
   |
77 |             let value_types = (0..to).map(|i| {
   |                                            ^ help: if this is intentional, prefix it with an underscore: `_i`

error[E0596]: cannot borrow `*ast_node` as mutable, as it is behind a `&` reference
  --> src/executable.rs:73:28
   |
73 |         let current_node = ast_node.visit(&self.fulltype).unwrap();
   |                            ^^^^^^^^ `ast_node` is a `&` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference
   |
72 |     pub fn labels(&self, to:usize, ast_node: &'a mut ASTNode) -> Vec<String> {
   |                                                  +++

error[E0596]: cannot borrow `*ast_node` as mutable, as it is behind a `&` reference
  --> src/executable.rs:96:32
   |
96 |             let current_node = ast_node.visit(&labels[i]).unwrap();
   |                                ^^^^^^^^ `ast_node` is a `&` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference
   |
92 |     pub fn children(&self, to: usize, ast_node: &'a mut ASTNode) -> Vec<Executable> {
   |                                                     +++

error[E0382]: borrow of moved value: `fulltype`
   --> src/executable.rs:104:36
    |
97  |             let fulltype = current_node.get("type").unwrap().to_string();
    |                 -------- move occurs because `fulltype` has type `std::string::String`, which does not implement the `Copy` trait
...
102 |                 fulltype, // fulltype
    |                 -------- value moved here
103 |                 Some(&self), // set the belongs_to to the current executable
104 |                 ASTNode::type_kind(&fulltype), // type kind of the current node
    |                                    ^^^^^^^^^ value borrowed here after move
    |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
   --> src/executable.rs:43:19
    |
40  |     pub fn new(
    |            --- in this method
...
43  |         fulltype: String,
    |                   ^^^^^^ this parameter takes ownership of the value
help: consider cloning the value if the performance cost is acceptable
    |
102 |                 fulltype.clone(), // fulltype
    |                         ++++++++

error[E0507]: cannot move out of `belongs_to.absolute_slot` as enum variant `Some` which is behind a shared reference
   --> src/executable.rs:160:37
    |
160 |             if let Some(abs_slot) = belongs_to.absolute_slot {
    |                         --------    ^^^^^^^^^^^^^^^^^^^^^^^^
    |                         |
    |                         data moved here
    |                         move occurs because `abs_slot` has type `std::string::String`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
160 |             if let Some(abs_slot) = &belongs_to.absolute_slot {
    |                                     +

warning: variable does not need to be mutable
  --> src/eth_call.rs:74:13
   |
74 | ...   let mut name_to_id: HashMap<String, i32> = id_to_network.as_object().unwrap().iter().map(|(k, v)| (v.as_str().unwrap().to_string(),...
   |           ----^^^^^^^^^^
   |           |
   |           help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `args`
  --> src/perf_expression_evaluator.rs:63:48
   |
63 |             ExpressionNode::FunctionCall(func, args) => {
   |                                                ^^^^ help: if this is intentional, prefix it with an underscore: `_args`

error[E0382]: borrow of moved value: `blob`
  --> src/ast_node.rs:87:20
   |
82 |     pub fn new(blob:Value) -> Self {
   |                ---- move occurs because `blob` has type `Value`, which does not implement the `Copy` trait
...
86 |             blob,
   |             ---- value moved here
87 |             types: blob["contracts"]["src/_utils/Dummy.sol"]["Dummy"]["storageLayout"]["types"],
   |                    ^^^^ value borrowed here after move
   |
help: consider cloning the value if the performance cost is acceptable
   |
86 |             blob: blob.clone(),
   |                 ++++++++++++++

error[E0507]: cannot move out of index of `Value`
  --> src/ast_node.rs:87:20
   |
87 |             types: blob["contracts"]["src/_utils/Dummy.sol"]["Dummy"]["storageLayout"]["types"],
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `Value`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
87 |             types: blob["contracts"]["src/_utils/Dummy.sol"]["Dummy"]["storageLayout"]["types"].clone(),
   |                                                                                                ++++++++

warning: variable does not need to be mutable
  --> src/main.rs:40:9
   |
40 |     let mut context = Context {
   |         ----^^^^^^^
   |         |
   |         help: remove this `mut`

Some errors have detailed explanations: E0382, E0507, E0596, E0621.
For more information about an error, try `rustc --explain E0382`.
warning: `mc-indexer-extractor` (bin "mc-indexer-extractor") generated 7 warnings
error: could not compile `mc-indexer-extractor` (bin "mc-indexer-extractor") due to 14 previous errors; 7 warnings emitted
